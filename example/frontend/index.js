/*
Nav can be generated by following the pattern in routesConfig.js
Pages can be created by following the pattern here and adding non-boilerplate html structure into the partials directory
*/

// django-like codeblock approach for html
async function loadPartial(url) {

    const response = await fetch(url);
    return response.text();

}

// new func to fetch data from backend instead of direct imports from backend
async function fetchDataFromBackend(queryKey, params) {

    const queryString = new URLSearchParams(params).toString();
    const response = await fetch(`/api/query/${queryKey}?${queryString}`);

    if (!response.ok) throw new Error("Server error");

    const result = await response.json();

    // update the query execution time.
    document.querySelector("#queryTime").textContent = `Query Execution Time: ${result.executionTime}`;

    return result.data;

}

// defining page components (could asbtract this too into framework - OR GIVER IT WITH routesCONFIG file copy with build command)
async function homePageComponent() {

    const div = document.createElement('div');
    div.innerHTML = await loadPartial('/partials/home.html');
    return div;

} // THIS AND ROUTESCONFIG HOME + SECRET EXAMPLE COULD BE ABSTARCTED INTO BUILD

async function limitPageComponent() {

    // page builder rough logic
    const div = document.createElement('div');
    div.innerHTML = await loadPartial('/partials/limit.html');

    // loading the example data table for movies inside moviesContainer which is placed inside limit partial which is placed inside index.html
    const tableContainer = div.querySelector("#moviesContainer");
    tableContainer.innerHTML = await loadPartial('/partials/movieTable.html');

    // dev IRL would use eventListeners in their example project which has to work with the more manual framework components as required by the task
    setTimeout(() => {
        const fetchBtn = div.querySelector("#fetchMovies");
        if (fetchBtn) {
            fetchBtn.addEventListener("click", async () => {
                const minRating = div.querySelector("#minRating").value;
                const maxRating = div.querySelector("#maxRating").value;
                const sortOrder = div.querySelector("#sortOrder").value;
                const limit = div.querySelector("#limit").value;

                try {
                    const queryStart = performance.now();
                    const movies = await fetchDataFromBackend("fetchMoviesByRange", { minRating, maxRating, sortOrder, limit });
                    const queryEnd = performance.now();

                    console.log("Fetched movies:", movies);

                    div.querySelector("#queryTime").textContent = `${(queryEnd - queryStart).toFixed(2)}ms`;

                    const renderStart = performance.now();
                    const tbody = div.querySelector("#moviesTableBody");
                    tbody.innerHTML = "";

                    movies.forEach(movie => {
                        const row = document.createElement("tr");
                        row.innerHTML = `
                            <td>${movie.title}</td>
                            <td>${movie.avg_rating ?? 'N/A'} (${movie.review_count} reviews)</td>
                        `;
                        tbody.appendChild(row);
                    });

                    const renderEnd = performance.now();
                    div.querySelector("#renderTime").textContent = `${(renderEnd - renderStart).toFixed(2)}ms`;

                } catch (error) {
                    div.querySelector("#movieResults").textContent = "Error fetching data. Please try again.";
                    console.error("Error fetching movie data:", error);
                }
            });
        }
    }, 50); // short delay just in case

    return div;

}

async function draftsPageComponent() {

    const div = document.createElement('div');
    div.innerHTML = await loadPartial('/partials/drafts.html');

    setTimeout(() => {

        const createPostBtn = document.getElementById("add-post");
        const savePostBtn = document.getElementById("save-post");
        const editLatestPostBtn = document.getElementById("edit-post");
        const publishPostBtn = document.getElementById("publish-post");
        const addTimestampBtn = document.getElementById("add-timestamp");
        const deleteBtn = document.getElementById("delete-posts");
                
        const textArea = document.getElementById("postContent");
    
        // create post and load default content
        if (createPostBtn) {
    
            createPostBtn.addEventListener("click", async () => {
    
                try {
    
                    const response = await fetch("/api/query/createPost", {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({})
                    });
        
                    if (!response.ok) throw new Error("Failed to create post");
        
                    const result = await response.json();
    
                    if (!result.postId) {
                        console.warn("Post creation failed");
                        return;
                    }
        
                    const textArea = document.getElementById("postContent");
                    if (textArea) {
                        textArea.value = result.content || "Your content... (to save or publish, it must be valid timestamp in this example)"; // slight difference from DB insert to find when fallback is used
                    }
        
                    updateButtonStates();
                    updateTableCounts();
        
                } catch (error) {
    
                    console.error("Error adding post:", error);
    
                }
    
            });
    
        }
    
        // add content (timestamp) for post in edit mode - this is just frontend action mimikcing content in controlled fashion, as content itself is irrelevant.
        if (addTimestampBtn) {
    
            addTimestampBtn.addEventListener("click", () => {
    
                if (textArea) {
                    // overwirting - can check clean ISO date in inputConig validation
                    textArea.value = new Date().toISOString();
                }
    
                updateButtonStates(); // keeps UI state "in sync" but no need for table counts
    
            });
    
        }
    
        // save post == move to draft_storage from edit_draft
        if (savePostBtn) {
    
            savePostBtn.addEventListener("click", async () => {
    
                const postId = await getActivePostId();
                const content = textArea.value.trim();
    
                try {
    
                    const response = await fetch("/api/query/moveToDrafts", {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ id: postId, content })
                    });
        
                    if (!response.ok) throw new Error("Failed to save post");
        
                    updateButtonStates();
                    updateTableCounts();
        
                    // clear text area as post is moved away
                    if (textArea) {
                        textArea.value = "";
                    }
        
                } catch (error) {
    
                    console.error("Error saving post:", error);
    
                }
    
            });
    
        }
    
        // publish post == move to published_posts from edit_draft
        if (publishPostBtn) {
    
            publishPostBtn.addEventListener("click", async () => {
    
                const postId = await getActivePostId();
                const content = textArea.value.trim();
    
                try {
    
                    const response = await fetch("/api/query/moveToPublished", {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ id: postId, content })
                    });
    
                    if (!response.ok) throw new Error("Failed to publish post");
    
                    updateButtonStates();
                    updateTableCounts();
    
                    // clear text area as post is moved away
                    if (textArea) {
                        textArea.value = "";
                    }
    
                } catch (error) {
    
                    console.error("Error publishing post:", error);
    
                }
    
            });
    
        }
    
        // Edit post is an atomic transaction here too, because we are moving a post from published or draft storage to edit drafts and we also need to load the content to the text input box - editing as a feature is a DB state
        if (editLatestPostBtn) {
    
            editLatestPostBtn.addEventListener("click", async () => {
    
                try {
    
                    const response = await fetch("/api/query/editLatestPost", {
                        method: "POST",
                        headers: { "Content-Type": "application/json" }
                    });
        
                    if (!response.ok) throw new Error("Failed to edit latest post");
        
                    const result = await response.json();
        
                    if (!result.postId) {
                        console.warn("No latest post found for editing.");
                        return;
                    }
        
                    const textArea = document.getElementById("postContent");
                    if (textArea) {
                        textArea.value = result.content || "Failed to fetch post - please try again.";
                    }
    
                    updateButtonStates();
                    updateTableCounts();
    
                } catch (error) {
    
                    console.error("Error adding post:", error);
    
                }
    
            });
    
        }
    
        // drop all posts from every table
        if (deleteBtn) {
    
            deleteBtn.addEventListener("click", async () => {
    
                try {
    
                    const response = await fetch("/api/query/deleteAllPosts", {
                        method: "POST",
                        headers: { "Content-Type": "application/json" }
                    });
            
                    if (!response.ok) throw new Error("Failed to delete all posts");
            
                    updateButtonStates();
                    updateTableCounts();
    
                    // could do db route too, but overkill, so just cleaning out
                    const textArea = document.getElementById("postContent");
                    if (textArea) {
                        textArea.value = "";
                    }
            
                } catch (error) {
    
                    console.error("Error deleting posts:", error);
    
                }
    
            });
    
        }

    }, 50);

    return div;

}

async function accessPageComponent() {

    const div = document.createElement('div');
    div.innerHTML = await loadPartial('/partials/access.html');

    // for presentation 1
    try {

        const response = await fetch("/api/access/relations");
        const result = await response.json();

        const accessContainer = div.querySelector("#accessData");

        if (!result.data.length) {
            accessContainer.innerHTML = "<p>No user relations found.</p>";
            return div;
        }

        let htmlContent = `<p><span class="spanbold">Derived user relations or actions:</span><table border="1">
            <tr>
                <th>User</th>
                <th>Other User</th>
                <th>Action Type</th>
                <th>Block Status</th>
            </tr>`;

        result.data.forEach(entry => {
            htmlContent += `<tr>
                <td>${entry.username}</td>
                <td>${entry.other_username}</td>
                <td>${entry.relation_type}</td>
                <td>${entry.block_status}</td>
            </tr>`;
        });

        htmlContent += "</table>";

        accessContainer.innerHTML = htmlContent;

    } catch (error) {

        console.error("Error loading access data:", error);

    }

    // for presentation 2
    try {

        const response = await fetch("/api/access/relations2");
        const result = await response.json();

        const accessContainer = div.querySelector("#accessData2");

        if (!result.data.length) {
            accessContainer.innerHTML = "<p>No user relations found.</p>";
            return div;
        }

        let htmlContent = `<p><span class="spanbold">Derived user relations or actions:</span><table border="1">
            <tr>
                <th>User</th>
                <th>Other User</th>
                <th>Action Type</th>
                <th>Block Status</th>
            </tr>`;

        result.data.forEach(entry => {
            htmlContent += `<tr>
                <td>${entry.username}</td>
                <td>${entry.other_username}</td>
                <td>${entry.relation_type}</td>
                <td>${entry.block_status}</td>
            </tr>`;
        });

        htmlContent += "</table>";

        accessContainer.innerHTML = htmlContent;

    } catch (error) {

        console.error("Error loading access data:", error);

    }

    // for presentation 3
    try {

        const response = await fetch("/api/access/relations3");
        const result = await response.json();

        const accessContainer = div.querySelector("#accessData3");

        if (!result.data.length) {
            accessContainer.innerHTML = "<p>No user relations found.</p>";
            return div;
        }

        let htmlContent = `<p><span class="spanbold">Derived user relations or actions:</span><table border="1">
            <tr>
                <th>User</th>
                <th>Other User</th>
                <th>Action Type</th>
                <th>Block Status</th>
            </tr>`;

        result.data.forEach(entry => {
            htmlContent += `<tr>
                <td>${entry.username}</td>
                <td>${entry.other_username}</td>
                <td>${entry.relation_type}</td>
                <td>${entry.block_status}</td>
            </tr>`;
        });

        htmlContent += "</table>";

        accessContainer.innerHTML = htmlContent;

    } catch (error) {

        console.error("Error loading access data:", error);

    }

    // example 2 for admin permission
    try {

        const response = await fetch("/api/access/permissions");
        const result = await response.json();

        const accessContainer = div.querySelector("#accessData4");

        if (!result.data.length) {
            accessContainer.innerHTML = "<p>No permissions found.</p>";
            return;
        }

        let htmlContent = `<p><span class="spanbold">Derived user permissions:</span></p>
            <table border="1">
            <tr>
                <th>User</th>
                <th>Space</th>
                <th>Access Status</th>
                <th>Valid Log Exists</th>
            </tr>`;

        result.data.forEach(entry => {
            htmlContent += `<tr>
                <td>${entry.username}</td>
                <td>${entry.space_name}</td>
                <td>${entry.access_status}</td>
                <td>${entry.has_valid_permission_log ? 'Yes' : 'No'}</td>
            </tr>`;
        });

        htmlContent += "</table>";

        accessContainer.innerHTML = htmlContent;

    } catch (error) {

        console.error("Error loading access permissions:", error);

    }

    return div;

}

// helper to get post ID which is in edit "mode" - in the drafts table and active
async function getActivePostId() {
    
    const response = await fetch("/api/query/fetchEditDraftPost");
    const result = await response.json();
    return result.postId || null;

}

document.addEventListener("DOMContentLoaded", function () {
    
    // defining routes - (sort of follows a Django-style routing structure)
    defineRoute('/', homePageComponent);
    defineRoute('/limit', limitPageComponent);
    // defineRoute('/drafts', draftsPageComponent);
    defineRoute('/drafts', async () => {
        const div = await draftsPageComponent();
        updateButtonStates(); // await comes with null error, but does not matter much atm for example
        return div;
    });
    defineRoute('/access', accessPageComponent);
    
    // kickstarts the entire frontend logic
    initClientApp();

});